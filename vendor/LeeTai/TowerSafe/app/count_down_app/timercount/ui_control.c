// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.0
// LVGL version: 8.3.6
// Project name: SquareLine_Project
// ui_control.ca功能
// 获取到当前选择的时间
// 点击开始按钮，从选择的时间开始倒计时
// 点击清理按钮，时间变为初始化，00:10
#include "ui.h"

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include "los_task.h"
#include "los_event.h"
#include "los_swtmr.h"
// #include "ohos_run.h"

#define FLAGS_MSK1 0x00000001U
#define FLAGS_MSK2 0x00000002U
#define DELAY_100_TICKS 1000U
#define TASK_STACK_SIZE 4096
#define TASK_PRIO 5
static EVENT_CB_S g_event;
int ui_MinTimeID = 0;
int ui_SecTimeID = 0;
int countTime = 0; // 总秒
enum ui_Button_status
{
	BT_WAIT,
	BT_START,
	BT_PAUSE,
	BT_CONTINUE
}; // 按钮状态
enum ui_Button_status button_status = BT_WAIT;

/* Timer count */
UINT32 g_timerCount1 = 0;
#define TICKS_100 100U
UINT32 g_timerId1; // timer id1

// 点击开始按钮，发送开始计时事件
void start_ok(lv_event_t *e)
{
	// 获取到当前选择的时间
	// 获取roller 选项ID
	button_status++;
	switch (button_status)
	{
	case BT_START:
	{
		ui_MinTimeID = lv_roller_get_selected(ui_MinTime);
		ui_SecTimeID = lv_roller_get_selected(ui_SecTime);
		countTime = ui_MinTimeID * 60 + ui_SecTimeID; // 获取总秒数
		printf("Total count:%d\n", countTime);

		// 改变开始按钮内容为 Pause暂停，颜色为橙色
		lv_label_set_text(ui_Label1, "Pause");
		lv_obj_set_style_bg_color(ui_Button1, lv_color_hex(0xf88379), LV_STATE_DEFAULT);
		lv_obj_set_style_bg_color(ui_Panel1, lv_color_hex(0x2095F6), LV_PART_MAIN | LV_STATE_DEFAULT);

		// 发送开始计时事件
		OS_Thread_EventSender(FLAGS_MSK1);
		break;
	}
	case BT_PAUSE:
	{   
        LOS_SwtmrStop(g_timerId1);
		// 改变开始按钮内容为 Pause暂停，颜色为绿色
		lv_label_set_text(ui_Label1, "GoOn");
		lv_obj_set_style_bg_color(ui_Button1, lv_color_hex(0xbce672), LV_STATE_DEFAULT);
		break;
	}
	case BT_CONTINUE:
	{
        LOS_SwtmrStart(g_timerId1);
		// 改变开始按钮内容为 Pause暂停，颜色为橙色
		lv_label_set_text(ui_Label1, "Pause");
		lv_obj_set_style_bg_color(ui_Button1, lv_color_hex(0xf88379), LV_STATE_DEFAULT);
		button_status=BT_START;
		break;
	}
	defalut:
	{
		break;
	}
	}
}

// 点击清零按钮，发送停止计时事件
void clear_ok(lv_event_t *e)
{
	// 修改当前roller选项内容,
	lv_roller_set_selected(ui_MinTime, 0, LV_ANIM_ON);
	lv_roller_set_selected(ui_SecTime, 10, LV_ANIM_ON);
	lv_label_set_text(ui_Label1, "Start");
	lv_obj_set_style_bg_color(ui_Button1, lv_color_hex(0xF88379), LV_PART_MAIN | LV_STATE_FOCUSED);
    lv_obj_set_style_bg_color(ui_Panel1, lv_color_hex(0x2095F6), LV_PART_MAIN | LV_STATE_DEFAULT);

	// 发送结束计时事件
	OS_Thread_EventSender(FLAGS_MSK2);
	button_status=BT_WAIT;
}

// 发送事件
void OS_Thread_EventSender(UINT32 argument)
{
	printf("will Send eventFlags %d .\n", argument);
	switch (argument)
	{
	case FLAGS_MSK1: // 开始计时
	{
		if (LOS_EventWrite(&g_event, FLAGS_MSK1) == LOS_OK)
		{
			printf("write eventFlags %d success.\n", FLAGS_MSK1);
		}
		else
		{
			printf("write eventFlags %d failed.\n", LOS_EventWrite(&g_event, FLAGS_MSK1));
		}
		break;
	}
	case FLAGS_MSK2: // 停止计时
	{
		if (LOS_EventWrite(&g_event, FLAGS_MSK2) == LOS_OK)
		{
			printf("write eventFlags %d success.\n", FLAGS_MSK2);
		}
		else
		{
			printf("write eventFlags %d failed.\n", LOS_EventWrite(&g_event, FLAGS_MSK2));
		}
		break;
	}
	default:
		printf("send FLAGS_MAK FAILED!\r\n");
		break;
	}
}

// 接收事件 开始计时
void OS_Thread_EventReceiverOR(UINT32 argument)
{
	(void)argument;
	UINT32 flags;

	while (1)
	{
		printf("enter OS_Thread_EventReceiverOR\r\n");
		flags = LOS_EventRead(&g_event, FLAGS_MSK1 | FLAGS_MSK2, LOS_WAITMODE_OR | LOS_WAITMODE_CLR, 0xFFFFFFFFU);
		printf("EventReceiverOR wait event! Receive Flags is %d\n", flags);

		if (flags == FLAGS_MSK1) // 开始计时
		{
			LOS_SwtmrStart(g_timerId1); // 启动单次软件定时器
			printf("start Timer1 success\n");
		}

		if (flags == FLAGS_MSK2) // 结束计时
		{
			LOS_SwtmrStop(g_timerId1);
			printf("stop Timer1 success\n");
			g_timerCount1 = 0;
			countTime = 0;
		}
		LOS_TaskDelay(10);
	}
}

void Timer1_Callback(UINT32 arg) // 回调函数1
{
	UINT32 tick_last1;
	g_timerCount1++;
	if (g_timerCount1 == countTime) // 到计时结束
	{
		g_timerCount1 = 0;
		LOS_SwtmrStop(g_timerId1);
		printf("countTime OUT----stop Timer1 success\n");
		ui_MinTimeID = 0;
		ui_SecTimeID = 0;
		lv_roller_set_selected(ui_MinTime, ui_MinTimeID, LV_ANIM_ON);
		lv_roller_set_selected(ui_SecTime, ui_SecTimeID, LV_ANIM_ON);
		lv_obj_set_style_bg_color(ui_Panel1, lv_color_hex(0xf88379), LV_PART_MAIN | LV_STATE_DEFAULT);
		return;
	}
	else // 刷新倒计时的 分- 秒
	{
		ui_MinTimeID = (countTime - g_timerCount1) / 60;
		ui_SecTimeID = (countTime - g_timerCount1) % 60;
		lv_roller_set_selected(ui_MinTime, ui_MinTimeID, LV_ANIM_ON);
		lv_roller_set_selected(ui_SecTime, ui_SecTimeID, LV_ANIM_ON);
	}
	tick_last1 = (UINT32)LOS_TickCountGet(); // 获取当前Tick数
	printf("g_timerCount1=%d, tick_last1=%d\n", g_timerCount1, tick_last1);
}

// 事件测试Example
void OS_Event_example(void)
{

	printf("enter OS_Event_example!\n");
	if (LOS_EventInit(&g_event) != LOS_OK)
	{
		printf("Failed to create EventFlags!\n");
		return;
	}

	LOS_SwtmrCreate(TICKS_100, LOS_SWTMR_MODE_PERIOD, Timer1_Callback, &g_timerId1, 1,
					OS_SWTMR_ROUSES_ALLOW, OS_SWTMR_ALIGN_INSENSITIVE);
	printf("create Timer1 success\n");

	LOS_TaskLock();
	TSK_INIT_PARAM_S attr = {0};
	attr.pcName = "Thread_EventReceiverOR";
	attr.pfnTaskEntry = (TSK_ENTRY_FUNC)OS_Thread_EventReceiverOR;
	UINT32 taskIDEventRecvOR;
	if (LOS_TaskCreate(&taskIDEventRecvOR, &attr) != LOS_OK)
	{
		printf("Falied to create Thread_EventReceiverOR!\n");
		return;
	}
	printf("end OS_Event_example!\n");
	LOS_TaskUnlock();
}

void SelectMin(lv_event_t *e)
{
	// 获取roller 选项ID
	int ui_MinTimeID = lv_roller_get_selected(ui_MinTime);
	char buf_minTime[32];
	// 获取roller 选项内容
	lv_roller_get_selected_str(ui_MinTime, buf_minTime, sizeof(buf_minTime));
	printf("Selected MinTime ID:%d Text:%s\n", ui_MinTimeID, buf_minTime);
}

void SelectSec(lv_event_t *e)
{
	// 获取roller 选项ID
	int ui_SecTimeID = lv_roller_get_selected(ui_MinTime);
	char buf_secTime[32];
	// 获取roller 选项内容
	lv_roller_get_selected_str(ui_MinTime, buf_secTime, sizeof(buf_secTime));
	printf("Selected SecTime ID:%d Text:%s\n", ui_SecTimeID, buf_secTime);
}

// OHOS_APP_RUN(OS_Event_example);