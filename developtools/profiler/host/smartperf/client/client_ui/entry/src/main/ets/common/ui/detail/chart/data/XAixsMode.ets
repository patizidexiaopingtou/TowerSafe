import Transformer from '../utils/Transformer';
import XAxisRenderer from '../renderer/XAxisRenderer';
/*
 * Copyright (C) 2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import LimitLine from '../components/LimitLine';
import { XAxis } from '../components/XAxis';
import Paint from './Paint';
import ViewPortHandler from '../utils/ViewPortHandler';


export default class XAixsMode{

    paints:Paint[] = []
    handler:ViewPortHandler = new ViewPortHandler();
    topAxis:XAxis = new XAxis();
    bottomAxis:XAxis = new XAxis();
    width:number = 300;
    height:number = 300;
    minOffset:number = 15;
    yLeftLongestLabel:string="AAA"
    yRightLongestLabel:string="AAA"
    XLimtLine:LimitLine = new LimitLine(35, "Index 10");

    xPosition:number=0
    yPosition:number=0
    clipPath:string;

    public draw(){
        this.paints=[]
        let minYOffset=this.topAxis.getTextSize()+this.topAxis.getYOffset();
        this.minOffset=this.minOffset<minYOffset?minYOffset:this.minOffset

        this.handler.restrainViewPort(this.minOffset,this.minOffset,this.minOffset,this.minOffset)
        this.handler.setChartDimens(this.width,this.height);

        /*this.topAxis.setLabelCount(6, false);
        this.topAxis.setPosition(XAxisPosition.TOP);
        this.topAxis.setAxisMinimum(0);
        this.topAxis.setAxisMaximum(240);*/
        let mAxisRendererTop:XAxisRenderer = new XAxisRenderer(this.handler,this.topAxis,new Transformer(this.handler));
        mAxisRendererTop.yLeftLongestLabel=this.yLeftLongestLabel;
        mAxisRendererTop.yRightLongestLabel=this.yRightLongestLabel;
        mAxisRendererTop.computeAxis(this.topAxis.mAxisMinimum,this.topAxis.mAxisMaximum,false)
        this.paints = this.paints.concat(mAxisRendererTop.renderAxisLine());
        this.paints = this.paints.concat(mAxisRendererTop.renderAxisLabels())
        this.paints = this.paints.concat(mAxisRendererTop.renderGridLines())

        /*this.bottomAxis.setLabelCount(6, false);
        this.bottomAxis.setPosition(XAxisPosition.BOTTOM);
        this.bottomAxis.setAxisMinimum(0);
        this.bottomAxis.setAxisMaximum(240);*/
        let mAxisRendererBottom:XAxisRenderer = new XAxisRenderer(this.handler,this.bottomAxis,new Transformer(this.handler));
        mAxisRendererBottom.yLeftLongestLabel=this.yLeftLongestLabel;
        mAxisRendererBottom.yRightLongestLabel=this.yRightLongestLabel;
        mAxisRendererBottom.computeAxis(this.bottomAxis.mAxisMinimum,this.bottomAxis.mAxisMaximum,false)
        this.paints = this.paints.concat(mAxisRendererBottom.renderAxisLine());
        this.paints = this.paints.concat(mAxisRendererBottom.renderAxisLabels())

        this.paints = this.paints.concat(mAxisRendererTop.renderLimitLines());

        let arr = [];
        for(let item of this.paints){
            if(item){
                arr.push(item);
            }
        }

        this.paints = arr;
    }
}